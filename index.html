<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Speed Reader">
  <meta name="theme-color" content="#000000">
  <title>Speed Reader</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-color, #000);
      color: var(--text-color, #fff);
      min-height: 100vh;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      transition: background-color 0.3s, color 0.3s;
    }
    
    .upload-screen {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      flex-direction: column;
      padding: 2rem;
    }
    
    .upload-area {
      border: 3px dashed var(--text-color, #fff);
      border-radius: 20px;
      padding: 4rem 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      max-width: 500px;
      width: 100%;
    }
    
    .upload-area:hover {
      border-color: var(--anchor-color, #ff0000);
      transform: scale(1.02);
    }
    
    .upload-area.dragover {
      border-color: var(--anchor-color, #ff0000);
      background: rgba(255, 0, 0, 0.1);
    }
    
    .upload-icon {
      font-size: 5rem;
      margin-bottom: 1.5rem;
    }
    
    .upload-area h2 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }
    
    .upload-area p {
      color: #999;
      font-size: 1rem;
    }
    
    .recent-docs {
      margin-top: 2rem;
      max-width: 500px;
      width: 100%;
    }
    
    .recent-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #999;
    }
    
    .recent-list {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    
    .recent-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .recent-item:hover {
      border-color: var(--anchor-color, #ff0000);
      background: rgba(255, 0, 0, 0.1);
    }
    
    .recent-info {
      flex: 1;
    }
    
    .recent-name {
      font-weight: bold;
      margin-bottom: 0.3rem;
    }
    
    .recent-meta {
      font-size: 0.85rem;
      color: #999;
    }
    
    .reader-screen {
      display: none;
      min-height: 100vh;
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .reader-screen.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .word-container {
      text-align: center;
      padding: 2rem;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100%;
    }
    
    .word-display {
      font-size: 4rem;
      font-family: var(--font-family, 'Courier New'), monospace;
      font-weight: bold;
      letter-spacing: 3px;
      line-height: 1.5;
      max-width: 90vw;
      word-wrap: break-word;
      transition: font-size 0.2s;
      color: var(--text-color, #fff);
    }
    
    .word-before {
      color: var(--text-color, #fff);
    }
    
    .word-orp {
      color: var(--anchor-color, #ff0000);
      font-size: 1.125em;
    }
    
    .word-after {
      color: var(--text-color, #fff);
    }
    
    .control-btn {
      position: fixed;
      width: 60px;
      height: 60px;
      background: var(--text-color, #fff);
      color: var(--bg-color, #000);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3);
      transition: all 0.3s;
      z-index: 1000;
      opacity: 1;
    }
    
    .control-btn.fade {
      opacity: 0;
      pointer-events: none;
    }
    
    .control-btn:hover {
      transform: scale(1.1);
      background: var(--anchor-color, #ff0000);
      color: var(--text-color, #fff);
    }
    
    .settings-btn {
      bottom: 2rem;
      left: 2rem;
    }
    
    .play-pause-btn {
      bottom: 2rem;
      right: 2rem;
    }
    
    .settings-panel {
      position: fixed;
      top: 0;
      left: -100%;
      width: 100%;
      max-width: 450px;
      height: 100vh;
      background: var(--menu-bg, #1a1a1a);
      border-right: 2px solid #333;
      transition: left 0.3s;
      z-index: 1001;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    .settings-panel.active {
      left: 0;
    }
    
    .settings-header {
      padding: 1.5rem;
      border-bottom: 2px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      background: var(--menu-bg, #1a1a1a);
      z-index: 10;
    }
    
    .settings-title {
      font-size: 1.5rem;
      font-weight: bold;
    }
    
    .close-settings {
      background: none;
      border: none;
      color: var(--text-color, #fff);
      font-size: 1.8rem;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.3s;
    }
    
    .close-settings:hover {
      background: rgba(255, 0, 0, 0.2);
    }
    
    .settings-content {
      padding: 1.5rem;
      flex: 1;
    }
    
    .settings-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
    }
    
    .tab-btn {
      padding: 0.7rem 1.2rem;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid #333;
      border-radius: 8px;
      color: var(--text-color, #fff);
      cursor: pointer;
      transition: all 0.3s;
      white-space: nowrap;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .tab-btn:hover {
      border-color: var(--anchor-color, #ff0000);
    }
    
    .tab-btn.active {
      background: var(--anchor-color, #ff0000);
      border-color: var(--anchor-color, #ff0000);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .control-group {
      margin-bottom: 1.5rem;
    }
    
    .control-label {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-color, #fff);
      margin-bottom: 0.7rem;
      display: block;
    }
    
    .control-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .wpm-value {
      font-size: 1.3rem;
      color: var(--anchor-color, #ff0000);
      font-weight: bold;
      min-width: 100px;
      text-align: right;
    }
    
    .wpm-slider {
      flex: 1;
      min-width: 150px;
      height: 8px;
      border-radius: 10px;
      background: #333;
      outline: none;
      -webkit-appearance: none;
    }
    
    .wpm-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--anchor-color, #ff0000);
      cursor: pointer;
    }
    
    .wpm-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--anchor-color, #ff0000);
      cursor: pointer;
      border: none;
    }
    
    .color-input {
      width: 60px;
      height: 40px;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }
    
    .font-select, .mode-select {
      flex: 1;
      min-width: 150px;
      padding: 0.8rem;
      background: #333;
      color: var(--text-color, #fff);
      border: 2px solid #555;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
    }
    
    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: #333;
      border-radius: 30px;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .toggle-switch.active {
      background: var(--anchor-color, #ff0000);
    }
    
    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    
    .toggle-switch.active .toggle-slider {
      transform: translateX(30px);
    }
    
    .btn {
      width: 100%;
      padding: 1rem 1.5rem;
      border: 2px solid var(--text-color, #fff);
      background: transparent;
      color: var(--text-color, #fff);
      font-size: 1rem;
      font-weight: 700;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 0.8rem;
    }
    
    .btn:hover {
      background: var(--text-color, #fff);
      color: var(--bg-color, #000);
    }
    
    .btn-primary {
      background: var(--anchor-color, #ff0000);
      border-color: var(--anchor-color, #ff0000);
      color: #fff;
    }
    
    .btn-primary:hover {
      background: #cc0000;
      border-color: #cc0000;
    }
    
    .btn-danger {
      border-color: var(--anchor-color, #ff0000);
      color: var(--anchor-color, #ff0000);
    }
    
    .btn-danger:hover {
      background: var(--anchor-color, #ff0000);
      color: #fff;
    }
    
    .info-box {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1rem;
      font-size: 0.9rem;
      line-height: 1.5;
      margin-bottom: 1rem;
    }
    
    .warning-box {
      background: rgba(255, 0, 0, 0.1);
      border: 1px solid var(--anchor-color, #ff0000);
      border-radius: 8px;
      padding: 1rem;
      font-size: 0.85rem;
      color: #ff6666;
      line-height: 1.5;
      margin-bottom: 1rem;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 12px;
      padding: 1.2rem;
      margin-bottom: 1rem;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: var(--anchor-color, #ff0000);
      margin-bottom: 0.3rem;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #999;
    }
    
    .preset-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.8rem;
      margin-bottom: 1rem;
    }
    
    .preset-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid #333;
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      text-align: left;
    }
    
    .preset-btn:hover {
      border-color: var(--anchor-color, #ff0000);
      background: rgba(255, 0, 0, 0.1);
    }
    
    .preset-btn.active {
      border-color: var(--anchor-color, #ff0000);
      background: rgba(255, 0, 0, 0.15);
    }
    
    .preset-name {
      font-weight: bold;
      font-size: 0.95rem;
      color: var(--text-color, #fff);
      margin-bottom: 0.3rem;
    }
    
    .preset-desc {
      font-size: 0.75rem;
      color: #999;
      line-height: 1.3;
    }
    
    .custom-freq-input {
      width: 80px;
      padding: 0.6rem;
      background: #333;
      color: var(--text-color, #fff);
      border: 2px solid #555;
      border-radius: 8px;
      font-size: 1rem;
      text-align: center;
    }
    
    .custom-freq-input:focus {
      outline: none;
      border-color: var(--anchor-color, #ff0000);
    }
    
    .progress-info {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 0.8rem 1.5rem;
      text-align: center;
      color: #999;
      font-size: 0.85rem;
      z-index: 998;
      transition: opacity 0.3s;
    }
    
    .progress-info.fade {
      opacity: 0;
      pointer-events: none;
    }
    
    .timer-display {
      position: fixed;
      top: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 0.8rem 1.5rem;
      border-radius: 12px;
      font-size: 0.9rem;
      color: #999;
      z-index: 998;
      transition: opacity 0.3s;
    }
    
    .timer-display.fade {
      opacity: 0;
      pointer-events: none;
    }
    
    .hidden {
      display: none !important;
    }
    
    .section-divider {
      border-top: 1px solid #333;
      margin: 1.5rem 0;
    }
    
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.8rem;
      margin-bottom: 1rem;
    }
    
    .theme-preset {
      aspect-ratio: 1;
      border: 2px solid #333;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    
    .theme-preset:hover {
      border-color: var(--anchor-color, #ff0000);
      transform: scale(1.05);
    }
    
    .theme-preset.active {
      border-color: var(--anchor-color, #ff0000);
      border-width: 3px;
    }
    
    .theme-preview {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .theme-bg {
      flex: 2;
    }
    
    .theme-text {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    
    @media (orientation: landscape) {
      .settings-panel {
        max-width: 380px;
      }
      
      .word-display {
        font-size: 3rem;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 1.5rem;
      }
      
      .settings-btn {
        bottom: 1rem;
        left: 1rem;
      }
      
      .play-pause-btn {
        bottom: 1rem;
        right: 1rem;
      }
    }
    
    @media (max-width: 768px) {
      .word-display {
        font-size: 3rem;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 1.5rem;
      }
      
      .settings-btn {
        bottom: 1.5rem;
        left: 1.5rem;
      }
      
      .play-pause-btn {
        bottom: 1.5rem;
        right: 1.5rem;
      }
      
      .settings-panel {
        max-width: 100%;
      }
      
      .preset-grid {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 480px) {
      .word-display {
        font-size: 2.5rem;
      }
      
      .theme-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="upload-screen" id="uploadScreen">
    <div class="upload-area" id="uploadArea">
      <div class="upload-icon">üìö</div>
      <h2>Drop Document Here</h2>
      <p>PDF, DOCX, TXT supported</p>
    </div>
    <input type="file" id="fileInput" accept=".pdf,.docx,.doc,.txt" style="display: none;">
    
    <div class="recent-docs hidden" id="recentDocs">
      <div class="recent-title">Recent Documents</div>
      <div class="recent-list" id="recentList"></div>
    </div>
  </div>

  <div class="reader-screen" id="readerScreen">
    <div class="word-container">
      <div class="word-display" id="wordDisplayContainer">
        <span class="word-before" id="wordBefore"></span><span class="word-orp" id="wordOrp"></span><span class="word-after" id="wordAfter"></span>
      </div>
    </div>
    
    <button class="control-btn settings-btn" id="settingsBtn">‚öôÔ∏è</button>
    <button class="control-btn play-pause-btn" id="playPauseBtn">‚è∏Ô∏è</button>
    
    <div class="progress-info" id="progressInfo">
      <span id="progressText">Word 0 of 0</span> ‚Ä¢ <span id="progressPercent">0%</span> ‚Ä¢ <span id="timeRemaining">-- remaining</span>
    </div>
    
    <div class="timer-display hidden" id="timerDisplay">
      Session: <span id="sessionTimer">00:00</span>
    </div>
    
    <div class="settings-panel" id="settingsPanel">
      <div class="settings-header">
        <div class="settings-title">Settings</div>
        <button class="close-settings" id="closeSettings">‚úñ</button>
      </div>
      
      <div class="settings-content">
        <div class="settings-tabs">
          <button class="tab-btn active" data-tab="reading">üìñ Reading</button>
          <button class="tab-btn" data-tab="appearance">üé® Appearance</button>
          <button class="tab-btn" data-tab="audio">üéß Audio</button>
          <button class="tab-btn" data-tab="stats">üìä Statistics</button>
          <button class="tab-btn" data-tab="advanced">‚öôÔ∏è Advanced</button>
        </div>
        
        <!-- Reading Tab -->
        <div class="tab-content active" data-tab-content="reading">
          <div class="control-group">
            <label class="control-label">Reading Speed</label>
            <div class="control-item">
              <input type="range" class="wpm-slider" id="wpmSlider" min="100" max="1000" step="50" value="300">
              <span class="wpm-value" id="wpmDisplay">300 WPM</span>
            </div>
          </div>
          
          <div class="control-group">
            <label class="control-label">Reading Mode</label>
            <select class="mode-select" id="readingMode">
              <option value="single">Single Word (RSVP)</option>
              <option value="chunk2">2-Word Chunks</option>
              <option value="chunk3">3-Word Chunks</option>
            </select>
          </div>
          
          <div class="control-group">
            <label class="control-label">Pomodoro Timer</label>
            <div class="control-item">
              <span>25 min reading sessions</span>
              <div class="toggle-switch" id="pomodoroToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
            <div class="info-box hidden" id="pomodoroInfo">
              Timer will alert you every 25 minutes for a 5-minute break.
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <button class="btn btn-primary" id="resetBtn">üîÑ Reset to Beginning</button>
          <button class="btn" id="resumeBtn">‚ñ∂Ô∏è Continue Reading</button>
          <button class="btn btn-danger" id="exitBtn">‚úñ Close Document</button>
        </div>
        
        <!-- Appearance Tab -->
        <div class="tab-content" data-tab-content="appearance">
          <div class="control-group">
            <label class="control-label">Quick Themes</label>
            <div class="theme-grid" id="themeGrid"></div>
          </div>
          
          <div class="section-divider"></div>
          
          <div class="control-group">
            <label class="control-label">Font Family</label>
            <select class="font-select" id="fontSelect">
              <option value="'Courier New', monospace">Courier New</option>
              <option value="'Arial', sans-serif">Arial</option>
              <option value="'Georgia', serif">Georgia</option>
              <option value="'Times New Roman', serif">Times New Roman</option>
              <option value="'Verdana', sans-serif">Verdana</option>
              <option value="'Helvetica', sans-serif">Helvetica</option>
            </select>
          </div>
          
          <div class="control-group">
            <label class="control-label">Custom Colors</label>
            <div class="control-item">
              <span>Background</span>
              <input type="color" class="color-input" id="bgColorPicker" value="#000000">
            </div>
            <div class="control-item">
              <span>Text Color</span>
              <input type="color" class="color-input" id="textColorPicker" value="#ffffff">
            </div>
            <div class="control-item">
              <span>Anchor Color</span>
              <input type="color" class="color-input" id="anchorColorPicker" value="#ff0000">
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <div class="control-group">
            <label class="control-label">Display Options</label>
            <div class="control-item">
              <span>Show Session Timer</span>
              <div class="toggle-switch active" id="timerToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
            <div class="control-item">
              <span>Show Progress Bar</span>
              <div class="toggle-switch active" id="progressToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Audio Tab -->
        <div class="tab-content" data-tab-content="audio">
          <div class="control-group">
            <label class="control-label">üéß Binaural Beats</label>
            <div class="control-item">
              <span>Enable Binaural Audio</span>
              <div class="toggle-switch" id="binauralToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
            <div class="warning-box">
              ‚ö†Ô∏è Requires headphones for proper effect. Optional feature to enhance focus and learning through brainwave entrainment.
            </div>
          </div>
          
          <div id="binauralControls" class="hidden">
            <div class="control-group">
              <label class="control-label">Volume</label>
              <div class="control-item">
                <input type="range" class="wpm-slider" id="volumeSlider" min="0" max="100" step="5" value="30">
                <span class="wpm-value" id="volumeDisplay">30%</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Statistics Tab -->
        <div class="tab-content" data-tab-content="stats">
          <div class="control-group">
            <label class="control-label">Today's Progress</label>
            <div class="stat-card">
              <div class="stat-value" id="todayWords">0</div>
              <div class="stat-label">Words Read Today</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="todayTime">0 min</div>
              <div class="stat-label">Reading Time Today</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="avgWpm">0</div>
              <div class="stat-label">Average WPM</div>
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <div class="control-group">
            <label class="control-label">All-Time Statistics</label>
            <div class="stat-card">
              <div class="stat-value" id="totalWords">0</div>
              <div class="stat-label">Total Words Read</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="totalSessions">0</div>
              <div class="stat-label">Reading Sessions</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="readingStreak">0</div>
              <div class="stat-label">Day Streak</div>
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <button class="btn" id="exportStats">üìä Export Statistics</button>
          <button class="btn btn-danger" id="clearStats">üóëÔ∏è Clear All Statistics</button>
        </div>
        
        <!-- Advanced Tab -->
        <div class="tab-content" data-tab-content="advanced">
          <div class="control-group">
            <label class="control-label">OCR for Scanned PDFs</label>
            <div class="control-item">
              <span>Enable OCR Mode</span>
              <div class="toggle-switch" id="ocrToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
            <div class="warning-box">
              ‚ö†Ô∏è OCR Mode for scanned PDFs. Requires internet connection. May be slower to process.
            </div>
            <div class="info-box hidden" id="ocrStatus"></div>
          </div>
          
          <div class="section-divider"></div>
          
          <div class="control-group">
            <label class="control-label">Auto-Save & Bookmarks</label>
            <div class="control-item">
              <span>Auto-save position</span>
              <div class="toggle-switch active" id="autosaveToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
            <div class="info-box">
              Your reading position is automatically saved. Click "Continue Reading" to resume where you left off.
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <div class="control-group">
            <label class="control-label">Wake Lock</label>
            <div class="control-item">
              <span>Prevent screen sleep</span>
              <div class="toggle-switch active" id="wakelockToggle">
                <div class="toggle-slider"></div>
              </div>
            </div>
          </div>
          
          <div class="section-divider"></div>
          
          <button class="btn" id="exportSettings">üíæ Export Settings</button>
          <button class="btn" id="importSettings">üì• Import Settings</button>
          <input type="file" id="settingsFileInput" accept=".json" style="display: none;">
        </div>
      </div>
    </div>
  </div>

  <script>
    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }

    // PDF.js Configuration
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    // State Variables
    let words = [];
    let currentIndex = 0;
    let isPlaying = false;
    let wpm = 300;
    let interval = null;
    let ocrEnabled = false;
    let ocrWorker = null;
    let fadeTimeout = null;
    let sessionStartTime = null;
    let sessionInterval = null;
    let pomodoroInterval = null;
    let pomodoroEnabled = false;
    let wakeLock = null;
    let currentDocName = '';
    let currentDocHash = '';
    let readingMode = 'single';

    // Audio Variables
    let audioContext = null;
    let leftOscillator = null;
    let rightOscillator = null;
    let gainNode = null;
    let binauralEnabled = false;
    let currentFrequency = 15;
    let currentVolume = 0.3;

    const binauralPresets = {
      theta: { freq: 5, base: 200, name: 'Theta' },
      alpha: { freq: 10, base: 200, name: 'Alpha' },
      beta: { freq: 15, base: 200, name: 'Beta' },
      gamma: { freq: 40, base: 200, name: 'Gamma' }
    };

    // Theme Presets
    const themePresets = [
      { name: 'Dark', bg: '#000000', text: '#ffffff', anchor: '#ff0000' },
      { name: 'Light', bg: '#ffffff', text: '#000000', anchor: '#ff0000' },
      { name: 'Sepia', bg: '#f4ecd8', text: '#5c4b37', anchor: '#a0522d' },
      { name: 'Nord', bg: '#2e3440', text: '#eceff4', anchor: '#88c0d0' },
      { name: 'Dracula', bg: '#282a36', text: '#f8f8f2', anchor: '#ff79c6' },
      { name: 'Monokai', bg: '#272822', text: '#f8f8f2', anchor: '#f92672' }
    ];

    // DOM Elements
    const uploadScreen = document.getElementById('uploadScreen');
    const readerScreen = document.getElementById('readerScreen');
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const settingsBtn = document.getElementById('settingsBtn');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    const closeSettings = document.getElementById('closeSettings');
    const wpmSlider = document.getElementById('wpmSlider');
    const wpmDisplay = document.getElementById('wpmDisplay');
    const resetBtn = document.getElementById('resetBtn');
    const exitBtn = document.getElementById('exitBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const wordBefore = document.getElementById('wordBefore');
    const wordOrp = document.getElementById('wordOrp');
    const wordAfter = document.getElementById('wordAfter');
    const wordDisplayContainer = document.getElementById('wordDisplayContainer');
    const progressText = document.getElementById('progressText');
    const progressPercent = document.getElementById('progressPercent');
    const timeRemaining = document.getElementById('timeRemaining');
    const progressInfo = document.getElementById('progressInfo');
    const timerDisplay = document.getElementById('timerDisplay');
    const sessionTimer = document.getElementById('sessionTimer');
    const readingModeSelect = document.getElementById('readingMode');

    // Initialize
    loadPreferences();
    loadStatistics();
    loadRecentDocuments();
    initializeThemes();
    initializeTabNavigation();
    
    // Load Preferences
    function loadPreferences() {
      try {
        const savedFont = localStorage.getItem('fontFamily');
        const savedBg = localStorage.getItem('bgColor');
        const savedText = localStorage.getItem('textColor');
        const savedAnchor = localStorage.getItem('anchorColor');
        const savedWpm = localStorage.getItem('wpm');
        const savedMode = localStorage.getItem('readingMode');
        
        if (savedFont) {
          document.getElementById('fontSelect').value = savedFont;
          document.documentElement.style.setProperty('--font-family', savedFont);
        }
        if (savedBg) {
          document.getElementById('bgColorPicker').value = savedBg;
          applyColor('bg', savedBg);
        }
        if (savedText) {
          document.getElementById('textColorPicker').value = savedText;
          applyColor('text', savedText);
        }
        if (savedAnchor) {
          document.getElementById('anchorColorPicker').value = savedAnchor;
          applyColor('anchor', savedAnchor);
        }
        if (savedWpm) {
          wpm = parseInt(savedWpm);
          wpmSlider.value = wpm;
          wpmDisplay.textContent = `${wpm} WPM`;
        }
        if (savedMode) {
          readingMode = savedMode;
          readingModeSelect.value = savedMode;
        }
      } catch (error) {
        console.error('Error loading preferences:', error);
      }
    }

    function applyColor(type, color) {
      if (type === 'bg') {
        document.documentElement.style.setProperty('--bg-color', color);
        const lighter = lightenColor(color, 10);
        document.documentElement.style.setProperty('--menu-bg', lighter);
      } else if (type === 'text') {
        document.documentElement.style.setProperty('--text-color', color);
      } else if (type === 'anchor') {
        document.documentElement.style.setProperty('--anchor-color', color);
      }
    }

    function lightenColor(hex, percent) {
      const num = parseInt(hex.replace('#', ''), 16);
      const r = Math.min(255, ((num >> 16) & 0xff) + percent);
      const g = Math.min(255, ((num >> 8) & 0xff) + percent);
      const b = Math.min(255, (num & 0xff) + percent);
      return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    }

    // Initialize Themes
    function initializeThemes() {
      const themeGrid = document.getElementById('themeGrid');
      themePresets.forEach((theme, index) => {
        const div = document.createElement('div');
        div.className = 'theme-preset';
        if (index === 0) div.classList.add('active');
        div.innerHTML = `
          <div class="theme-preview">
            <div class="theme-bg" style="background: ${theme.bg}"></div>
            <div class="theme-text" style="background: ${theme.text}; color: ${theme.anchor}">A</div>
          </div>
        `;
        div.addEventListener('click', () => {
          document.querySelectorAll('.theme-preset').forEach(t => t.classList.remove('active'));
          div.classList.add('active');
          applyTheme(theme);
        });
        themeGrid.appendChild(div);
      });
    }

    function applyTheme(theme) {
      document.getElementById('bgColorPicker').value = theme.bg;
      document.getElementById('textColorPicker').value = theme.text;
      document.getElementById('anchorColorPicker').value = theme.anchor;
      applyColor('bg', theme.bg);
      applyColor('text', theme.text);
      applyColor('anchor', theme.anchor);
      localStorage.setItem('bgColor', theme.bg);
      localStorage.setItem('textColor', theme.text);
      localStorage.setItem('anchorColor', theme.anchor);
    }

    // Tab Navigation
    function initializeTabNavigation() {
      const tabBtns = document.querySelectorAll('.tab-btn');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const tab = btn.dataset.tab;
          tabBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          tabContents.forEach(content => {
            if (content.dataset.tabContent === tab) {
              content.classList.add('active');
            } else {
              content.classList.remove('active');
            }
          });
        });
      });
    }

    // Event Listeners - Appearance
    document.getElementById('fontSelect').addEventListener('change', (e) => {
      const font = e.target.value;
      document.documentElement.style.setProperty('--font-family', font);
      localStorage.setItem('fontFamily', font);
    });

    document.getElementById('bgColorPicker').addEventListener('input', (e) => {
      applyColor('bg', e.target.value);
      localStorage.setItem('bgColor', e.target.value);
    });

    document.getElementById('textColorPicker').addEventListener('input', (e) => {
      applyColor('text', e.target.value);
      localStorage.setItem('textColor', e.target.value);
    });

    document.getElementById('anchorColorPicker').addEventListener('input', (e) => {
      applyColor('anchor', e.target.value);
      localStorage.setItem('anchorColor', e.target.value);
    });

    // Reading Mode
    readingModeSelect.addEventListener('change', (e) => {
      readingMode = e.target.value;
      localStorage.setItem('readingMode', readingMode);
    });

    // Timer Toggle
    document.getElementById('timerToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      timerDisplay.classList.toggle('hidden');
    });

    // Progress Toggle
    document.getElementById('progressToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      progressInfo.classList.toggle('hidden');
    });

    // Pomodoro
    document.getElementById('pomodoroToggle').addEventListener('click', function() {
      pomodoroEnabled = !pomodoroEnabled;
      this.classList.toggle('active');
      document.getElementById('pomodoroInfo').classList.toggle('hidden');
      if (pomodoroEnabled && isPlaying) {
        startPomodoro();
      } else {
        stopPomodoro();
      }
    });

    function startPomodoro() {
      stopPomodoro();
      pomodoroInterval = setTimeout(() => {
        if (isPlaying) {
          togglePlayPause();
          alert('üçÖ Pomodoro break! Take 5 minutes to rest your eyes.');
        }
      }, 25 * 60 * 1000);
    }

    function stopPomodoro() {
      if (pomodoroInterval) {
        clearTimeout(pomodoroInterval);
        pomodoroInterval = null;
      }
    }

    // Wake Lock
    document.getElementById('wakelockToggle').addEventListener('click', async function() {
      this.classList.toggle('active');
      if (this.classList.contains('active')) {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
          }
        } catch (err) {
          console.error('Wake lock error:', err);
        }
      } else {
        if (wakeLock) {
          wakeLock.release();
          wakeLock = null;
        }
      }
    });

    // Binaural Beats
    document.getElementById('binauralToggle').addEventListener('click', function() {
      binauralEnabled = !binauralEnabled;
      this.classList.toggle('active');
      document.getElementById('binauralControls').classList.toggle('hidden');
      
      if (binauralEnabled) {
        initBinauralBeats();
      } else {
        stopBinauralBeats();
      }
    });

    function initBinauralBeats() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        gainNode.gain.value = currentVolume;
        gainNode.connect(audioContext.destination);
        startBinauralTone(currentFrequency);
      } catch (error) {
        console.error('Audio error:', error);
        alert('Audio not supported in this browser');
        binauralEnabled = false;
        document.getElementById('binauralToggle').classList.remove('active');
        document.getElementById('binauralControls').classList.add('hidden');
      }
    }

    function startBinauralTone(beatFreq) {
      if (!audioContext) return;
      stopBinauralTone();
      
      try {
        const baseFreq = 200;
        
        // Left channel
        leftOscillator = audioContext.createOscillator();
        leftOscillator.frequency.value = baseFreq;
        leftOscillator.type = 'sine';
        
        const leftGain = audioContext.createGain();
        leftGain.gain.value = 0.5;
        const leftMerger = audioContext.createChannelMerger(2);
        leftOscillator.connect(leftGain);
        leftGain.connect(leftMerger, 0, 0);
        
        // Right channel
        rightOscillator = audioContext.createOscillator();
        rightOscillator.frequency.value = baseFreq + beatFreq;
        rightOscillator.type = 'sine';
        
        const rightGain = audioContext.createGain();
        rightGain.gain.value = 0.5;
        const rightMerger = audioContext.createChannelMerger(2);
        rightOscillator.connect(rightGain);
        rightGain.connect(rightMerger, 0, 1);
        
        leftMerger.connect(gainNode);
        rightMerger.connect(gainNode);
        
        leftOscillator.start();
        rightOscillator.start();
      } catch (error) {
        console.error('Binaural tone error:', error);
      }
    }

    function stopBinauralTone() {
      try {
        if (leftOscillator) {
          leftOscillator.stop();
          leftOscillator = null;
        }
        if (rightOscillator) {
          rightOscillator.stop();
          rightOscillator = null;
        }
      } catch (error) {
        console.error('Stop tone error:', error);
      }
    }

    function stopBinauralBeats() {
      stopBinauralTone();
      if (audioContext) {
        try {
          audioContext.close();
          audioContext = null;
        } catch (error) {
          console.error('Audio context close error:', error);
        }
      }
    }

    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        const preset = binauralPresets[mode];
        
        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        currentFrequency = preset.freq;
        document.getElementById('customFreq').value = preset.freq;
        
        if (binauralEnabled && audioContext) {
          startBinauralTone(currentFrequency);
        }
      });
    });

    document.getElementById('customFreq').addEventListener('input', (e) => {
      const freq = parseFloat(e.target.value);
      if (freq >= 1 && freq <= 100) {
        currentFrequency = freq;
        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        
        if (binauralEnabled && audioContext) {
          startBinauralTone(currentFrequency);
        }
      }
    });

    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      const volume = parseInt(e.target.value);
      currentVolume = volume / 100;
      document.getElementById('volumeDisplay').textContent = `${volume}%`;
      
      if (gainNode) {
        gainNode.gain.value = currentVolume;
      }
    });

    // OCR
    document.getElementById('ocrToggle').addEventListener('click', function() {
      ocrEnabled = !ocrEnabled;
      this.classList.toggle('active');
      if (ocrEnabled && !ocrWorker) initOCR();
    });

    async function initOCR() {
      const ocrStatus = document.getElementById('ocrStatus');
      try {
        ocrStatus.textContent = '‚è≥ Initializing OCR...';
        ocrStatus.classList.remove('hidden');
        
        if (typeof Tesseract === 'undefined') {
          throw new Error('Tesseract library not loaded');
        }
        
        ocrWorker = await Tesseract.createWorker({
          logger: m => {
            if (m.status === 'recognizing text') {
              const percent = Math.round(m.progress * 100);
              ocrStatus.textContent = `üîç Processing... ${percent}%`;
            }
          }
        });
        
        await ocrWorker.loadLanguage('eng');
        await ocrWorker.initialize('eng');
        
        ocrStatus.textContent = '‚úì OCR Ready';
        setTimeout(() => ocrStatus.classList.add('hidden'), 2000);
      } catch (error) {
        console.error('OCR initialization error:', error);
        ocrStatus.textContent = '‚úñ OCR failed. Check connection.';
        ocrEnabled = false;
        document.getElementById('ocrToggle').classList.remove('active');
      }
    }

    // File Upload
    uploadArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) processFile(file);
    });

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) processFile(file);
    });

    async function processFile(file) {
      try {
        currentDocName = file.name;
        currentDocHash = await hashString(file.name + file.size);
        
        const ext = file.name.split('.').pop().toLowerCase();
        
        if (ext === 'pdf') {
          await processPDF(file);
        } else if (ext === 'docx' || ext === 'doc') {
          await processDOCX(file);
        } else if (ext === 'txt') {
          await processTXT(file);
        } else {
          alert('Unsupported file type. Please use PDF, DOCX, or TXT files.');
          return;
        }
        
        if (words.length > 0) {
          uploadScreen.classList.add('hidden');
          readerScreen.classList.add('active');
          
          // Check for saved position
          const saved = getSavedPosition(currentDocHash);
          if (saved && saved.index < words.length) {
            currentIndex = saved.index;
          } else {
            currentIndex = 0;
          }
          
          updateDisplay();
          autoStart();
          saveRecentDocument();
        } else {
          alert('No text found in document.');
        }
      } catch (error) {
        console.error('File processing error:', error);
        alert('Error processing file: ' + error.message);
      }
    }

    async function hashString(str) {
      const encoder = new TextEncoder();
      const data = encoder.encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function processPDF(file) {
      try {
        if (typeof pdfjsLib === 'undefined') {
          throw new Error('PDF.js library not loaded');
        }
        
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        let fullText = '';
        let hasText = false;
        
        // Check first few pages for text
        for (let i = 1; i <= Math.min(3, pdf.numPages); i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(' ');
          if (pageText.trim().length > 50) hasText = true;
        }
        
        if (ocrEnabled || !hasText) {
          if (!ocrWorker) {
            alert('Please enable OCR in settings first');
            return;
          }
          await processPDFWithOCR(pdf);
        } else {
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageHeight = page.view[3];
            
            const items = textContent.items.filter(item => {
              const y = item.transform[5];
              return y > pageHeight * 0.08 && y < pageHeight * 0.92;
            });
            
            fullText += items.map(item => item.str).join(' ') + ' ';
          }
          
          fullText = cleanText(fullText);
          words = fullText.split(/\s+/).filter(w => w.length > 0);
        }
      } catch (error) {
        console.error('PDF processing error:', error);
        throw new Error('Failed to process PDF: ' + error.message);
      }
    }

    async function processPDFWithOCR(pdf) {
      try {
        words = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 2.0 });
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          
          await page.render({ canvasContext: context, viewport: viewport }).promise;
          const { data } = await ocrWorker.recognize(canvas);
          
          const pageText = cleanText(data.text);
          words = words.concat(pageText.split(/\s+/).filter(w => w.length > 0));
        }
      } catch (error) {
        console.error('OCR processing error:', error);
        throw new Error('OCR processing failed: ' + error.message);
      }
    }

    async function processDOCX(file) {
      try {
        if (typeof mammoth === 'undefined') {
          throw new Error('Mammoth library not loaded');
        }
        
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
        const text = cleanText(result.value);
        words = text.split(/\s+/).filter(w => w.length > 0);
      } catch (error) {
        console.error('DOCX processing error:', error);
        throw new Error('Failed to process DOCX: ' + error.message);
      }
    }

    async function processTXT(file) {
      try {
        const text = await file.text();
        const cleanedText = cleanText(text);
        words = cleanedText.split(/\s+/).filter(w => w.length > 0);
      } catch (error) {
        console.error('TXT processing error:', error);
        throw new Error('Failed to process TXT: ' + error.message);
      }
    }

    function cleanText(text) {
      const tocPatterns = [
        /table\s+of\s+contents[\s\S]{0,500}?(?=chapter|introduction|preface|\n\n)/i,
        /contents[\s\S]{0,300}?(?=chapter|part|introduction|\d+\s*\n)/i,
        /isbn[:\s-]*[\dxX-]+/gi,
        /copyright\s*¬©[\s\S]{0,200}/gi,
        /all\s+rights\s+reserved[\s\S]{0,100}/gi,
        /published\s+by[\s\S]{0,150}/gi
      ];
      
      let cleaned = text;
      tocPatterns.forEach(pattern => {
        cleaned = cleaned.replace(pattern, ' ');
      });
      
      cleaned = cleaned.replace(/\s+/g, ' ').trim();
      return cleaned;
    }

    function findORP(word) {
      const len = word.length;
      if (len === 1) return 0;
      if (len <= 5) return 1;
      if (len <= 9) return 2;
      if (len <= 13) return 3;
      return 4;
    }

    function adjustFontSize(word) {
      const baseSize = window.innerWidth < 768 ? 3 : 4;
      const wordLength = word.length;
      
      if (wordLength > 25) {
        wordDisplayContainer.style.fontSize = (baseSize * 0.5) + 'rem';
      } else if (wordLength > 20) {
        wordDisplayContainer.style.fontSize = (baseSize * 0.6) + 'rem';
      } else if (wordLength > 15) {
        wordDisplayContainer.style.fontSize = (baseSize * 0.75) + 'rem';
      } else if (wordLength > 12) {
        wordDisplayContainer.style.fontSize = (baseSize * 0.85) + 'rem';
      } else {
        wordDisplayContainer.style.fontSize = baseSize + 'rem';
      }
    }

    function updateDisplay() {
      if (words.length === 0) return;
      
      try {
        let displayText = '';
        
        if (readingMode === 'single') {
          const word = words[currentIndex];
          const orp = findORP(word);
          adjustFontSize(word);
          wordBefore.textContent = word.slice(0, orp);
          wordOrp.textContent = word[orp] || '';
          wordAfter.textContent = word.slice(orp + 1);
        } else if (readingMode === 'chunk2') {
          const word1 = words[currentIndex] || '';
          const word2 = words[currentIndex + 1] || '';
          displayText = `${word1} ${word2}`;
          adjustFontSize(displayText);
          wordBefore.textContent = displayText;
          wordOrp.textContent = '';
          wordAfter.textContent = '';
        } else if (readingMode === 'chunk3') {
          const word1 = words[currentIndex] || '';
          const word2 = words[currentIndex + 1] || '';
          const word3 = words[currentIndex + 2] || '';
          displayText = `${word1} ${word2} ${word3}`;
          adjustFontSize(displayText);
          wordBefore.textContent = displayText;
          wordOrp.textContent = '';
          wordAfter.textContent = '';
        }
        
        const progress = ((currentIndex + 1) / words.length) * 100;
        progressText.textContent = `Word ${currentIndex + 1} of ${words.length}`;
        progressPercent.textContent = `${Math.round(progress)}%`;
        
        // Calculate time remaining
        const wordsLeft = words.length - currentIndex;
        const minutesLeft = Math.round(wordsLeft / wpm);
        timeRemaining.textContent = `${minutesLeft} min remaining`;
        
        // Save position if autosave enabled
        if (document.getElementById('autosaveToggle').classList.contains('active')) {
          savePosition();
        }
      } catch (error) {
        console.error('Display update error:', error);
      }
    }

    function savePosition() {
      if (!currentDocHash) return;
      try {
        localStorage.setItem(`position_${currentDocHash}`, JSON.stringify({
          index: currentIndex,
          timestamp: Date.now()
        }));
      } catch (error) {
        console.error('Save position error:', error);
      }
    }

    function getSavedPosition(hash) {
      try {
        const saved = localStorage.getItem(`position_${hash}`);
        return saved ? JSON.parse(saved) : null;
      } catch (error) {
        console.error('Get saved position error:', error);
        return null;
      }
    }

    function autoStart() {
      if (words.length > 0 && !isPlaying) {
        isPlaying = true;
        playPauseBtn.textContent = '‚è∏Ô∏è';
        startReading();
        startFadeTimer();
        startSessionTimer();
      }
    }

    // Session Timer
    function startSessionTimer() {
      sessionStartTime = Date.now();
      sessionInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        sessionTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }

    function stopSessionTimer() {
      if (sessionInterval) {
        clearInterval(sessionInterval);
        sessionInterval = null;
      }
    }

    // Controls
    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      settingsPanel.classList.add('active');
      showButtons();
      clearFadeTimer();
    });

    closeSettings.addEventListener('click', () => {
      settingsPanel.classList.remove('active');
    });

    playPauseBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePlayPause();
      showButtons();
      if (isPlaying) {
        startFadeTimer();
      } else {
        clearFadeTimer();
      }
    });

    function togglePlayPause() {
      if (words.length === 0) return;
      
      isPlaying = !isPlaying;
      
      if (isPlaying) {
        playPauseBtn.textContent = '‚è∏Ô∏è';
        startReading();
        if (!sessionInterval) startSessionTimer();
        if (pomodoroEnabled) startPomodoro();
      } else {
        playPauseBtn.textContent = '‚ñ∂Ô∏è';
        stopReading();
        stopPomodoro();
      }
    }

    readerScreen.addEventListener('click', (e) => {
      if (!settingsPanel.contains(e.target) && 
          e.target !== settingsBtn && 
          e.target !== playPauseBtn) {
        if (settingsPanel.classList.contains('active')) {
          settingsPanel.classList.remove('active');
        }
        showButtons();
        if (isPlaying) {
          startFadeTimer();
        }
      }
    });

    readerScreen.addEventListener('touchstart', (e) => {
      if (!settingsPanel.contains(e.target) && 
          e.target !== settingsBtn && 
          e.target !== playPauseBtn) {
        showButtons();
        if (isPlaying) {
          startFadeTimer();
        }
      }
    });

    document.addEventListener('mousemove', () => {
      if (readerScreen.classList.contains('active')) {
        showButtons();
        if (isPlaying && !settingsPanel.classList.contains('active')) {
          startFadeTimer();
        }
      }
    });

    function showButtons() {
      settingsBtn.classList.remove('fade');
      playPauseBtn.classList.remove('fade');
      progressInfo.classList.remove('fade');
      if (!timerDisplay.classList.contains('hidden')) {
        timerDisplay.classList.remove('fade');
      }
    }

    function hideButtons() {
      if (!settingsPanel.classList.contains('active')) {
        settingsBtn.classList.add('fade');
        playPauseBtn.classList.add('fade');
        progressInfo.classList.add('fade');
        if (!timerDisplay.classList.contains('hidden')) {
          timerDisplay.classList.add('fade');
        }
      }
    }

    function startFadeTimer() {
      clearFadeTimer();
      fadeTimeout = setTimeout(() => {
        hideButtons();
      }, 15000);
    }

    function clearFadeTimer() {
      if (fadeTimeout) {
        clearTimeout(fadeTimeout);
        fadeTimeout = null;
      }
    }

    wpmSlider.addEventListener('input', (e) => {
      wpm = parseInt(e.target.value);
      wpmDisplay.textContent = `${wpm} WPM`;
      localStorage.setItem('wpm', wpm);
      
      // Update time estimates
      updateDisplay();
      
      if (isPlaying) {
        stopReading();
        startReading();
      }
    });

    function startReading() {
      try {
        const chunkSize = readingMode === 'single' ? 1 : readingMode === 'chunk2' ? 2 : 3;
        const delay = (60 / wpm) * 1000 * chunkSize;
        
        interval = setInterval(() => {
          currentIndex += chunkSize;
          if (currentIndex >= words.length) {
            currentIndex = words.length - 1;
            stopReading();
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            isPlaying = false;
            showButtons();
            clearFadeTimer();
            
            // Save session stats
            saveSessionStats();
            return;
          }
          updateDisplay();
        }, delay);
      } catch (error) {
        console.error('Start reading error:', error);
      }
    }

    function stopReading() {
      if (interval) {
        clearInterval(interval);
        interval = null;
      }
    }

    resetBtn.addEventListener('click', () => {
      stopReading();
      isPlaying = false;
      currentIndex = 0;
      playPauseBtn.textContent = '‚è∏Ô∏è';
      updateDisplay();
      autoStart();
    });

    resumeBtn.addEventListener('click', () => {
      settingsPanel.classList.remove('active');
      if (!isPlaying) {
        togglePlayPause();
      }
    });

    exitBtn.addEventListener('click', () => {
      stopReading();
      stopBinauralBeats();
      stopSessionTimer();
      stopPomodoro();
      
      // Save final stats
      if (sessionStartTime) {
        saveSessionStats();
      }
      
      binauralEnabled = false;
      document.getElementById('binauralToggle').classList.remove('active');
      document.getElementById('binauralControls').classList.add('hidden');
      isPlaying = false;
      currentIndex = 0;
      words = [];
      currentDocName = '';
      currentDocHash = '';
      playPauseBtn.textContent = '‚è∏Ô∏è';
      readerScreen.classList.remove('active');
      uploadScreen.classList.remove('hidden');
      fileInput.value = '';
      settingsPanel.classList.remove('active');
      clearFadeTimer();
      showButtons();
      
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    });

    // Statistics
    function loadStatistics() {
      try {
        const stats = getStats();
        document.getElementById('todayWords').textContent = stats.todayWords.toLocaleString();
        document.getElementById('todayTime').textContent = `${Math.round(stats.todayTime / 60)} min`;
        document.getElementById('avgWpm').textContent = stats.avgWpm || wpm;
        document.getElementById('totalWords').textContent = stats.totalWords.toLocaleString();
        document.getElementById('totalSessions').textContent = stats.totalSessions;
        document.getElementById('readingStreak').textContent = stats.streak;
      } catch (error) {
        console.error('Load statistics error:', error);
      }
    }

    function getStats() {
      try {
        const stats = localStorage.getItem('readingStats');
        if (!stats) {
          return {
            todayWords: 0,
            todayTime: 0,
            avgWpm: 0,
            totalWords: 0,
            totalSessions: 0,
            streak: 0,
            lastDate: null,
            sessions: []
          };
        }
        return JSON.parse(stats);
      } catch (error) {
        console.error('Get stats error:', error);
        return {
          todayWords: 0,
          todayTime: 0,
          avgWpm: 0,
          totalWords: 0,
          totalSessions: 0,
          streak: 0,
          lastDate: null,
          sessions: []
        };
      }
    }

    function saveStats(stats) {
      try {
        localStorage.setItem('readingStats', JSON.stringify(stats));
        loadStatistics();
      } catch (error) {
        console.error('Save stats error:', error);
      }
    }

    function saveSessionStats() {
      if (!sessionStartTime) return;
      
      try {
        const stats = getStats();
        const sessionDuration = Math.floor((Date.now() - sessionStartTime) / 1000);
        const wordsRead = currentIndex;
        const today = new Date().toDateString();
        
        // Calculate streak
        if (stats.lastDate !== today) {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          if (stats.lastDate === yesterday.toDateString()) {
            stats.streak++;
          } else if (stats.lastDate !== today) {
            stats.streak = 1;
          }
          stats.lastDate = today;
          stats.todayWords = 0;
          stats.todayTime = 0;
        }
        
        stats.todayWords += wordsRead;
        stats.todayTime += sessionDuration;
        stats.totalWords += wordsRead;
        stats.totalSessions++;
        
        // Calculate average WPM
        const sessionWpm = Math.round((wordsRead / sessionDuration) * 60);
        if (stats.sessions) {
          stats.sessions.push({ wpm: sessionWpm, words: wordsRead, duration: sessionDuration, date: Date.now() });
          if (stats.sessions.length > 100) stats.sessions.shift();
          const totalWpm = stats.sessions.reduce((sum, s) => sum + s.wpm, 0);
          stats.avgWpm = Math.round(totalWpm / stats.sessions.length);
        } else {
          stats.sessions = [{ wpm: sessionWpm, words: wordsRead, duration: sessionDuration, date: Date.now() }];
          stats.avgWpm = sessionWpm;
        }
        
        saveStats(stats);
      } catch (error) {
        console.error('Save session stats error:', error);
      }
    }

    document.getElementById('exportStats').addEventListener('click', () => {
      try {
        const stats = getStats();
        const dataStr = JSON.stringify(stats, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'speed-reader-stats.json';
        link.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Export stats error:', error);
        alert('Error exporting statistics');
      }
    });

    document.getElementById('clearStats').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all statistics? This cannot be undone.')) {
        try {
          localStorage.removeItem('readingStats');
          loadStatistics();
        } catch (error) {
          console.error('Clear stats error:', error);
        }
      }
    });

    // Settings Import/Export
    document.getElementById('exportSettings').addEventListener('click', () => {
      try {
        const settings = {
          fontFamily: localStorage.getItem('fontFamily'),
          bgColor: localStorage.getItem('bgColor'),
          textColor: localStorage.getItem('textColor'),
          anchorColor: localStorage.getItem('anchorColor'),
          wpm: localStorage.getItem('wpm'),
          readingMode: localStorage.getItem('readingMode')
        };
        const dataStr = JSON.stringify(settings, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'speed-reader-settings.json';
        link.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Export settings error:', error);
        alert('Error exporting settings');
      }
    });

    document.getElementById('importSettings').addEventListener('click', () => {
      document.getElementById('settingsFileInput').click();
    });

    document.getElementById('settingsFileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const settings = JSON.parse(text);
        
        if (settings.fontFamily) {
          localStorage.setItem('fontFamily', settings.fontFamily);
          document.getElementById('fontSelect').value = settings.fontFamily;
          document.documentElement.style.setProperty('--font-family', settings.fontFamily);
        }
        if (settings.bgColor) {
          localStorage.setItem('bgColor', settings.bgColor);
          document.getElementById('bgColorPicker').value = settings.bgColor;
          applyColor('bg', settings.bgColor);
        }
        if (settings.textColor) {
          localStorage.setItem('textColor', settings.textColor);
          document.getElementById('textColorPicker').value = settings.textColor;
          applyColor('text', settings.textColor);
        }
        if (settings.anchorColor) {
          localStorage.setItem('anchorColor', settings.anchorColor);
          document.getElementById('anchorColorPicker').value = settings.anchorColor;
          applyColor('anchor', settings.anchorColor);
        }
        if (settings.wpm) {
          wpm = parseInt(settings.wpm);
          localStorage.setItem('wpm', settings.wpm);
          wpmSlider.value = wpm;
          wpmDisplay.textContent = `${wpm} WPM`;
        }
        if (settings.readingMode) {
          readingMode = settings.readingMode;
          localStorage.setItem('readingMode', settings.readingMode);
          readingModeSelect.value = settings.readingMode;
        }
        
        alert('Settings imported successfully!');
      } catch (error) {
        console.error('Import settings error:', error);
        alert('Error importing settings: ' + error.message);
      }
    });

    // Recent Documents & Library
    function saveRecentDocument() {
      try {
        const recent = getRecentDocuments();
        const doc = {
          name: currentDocName,
          hash: currentDocHash,
          timestamp: Date.now(),
          wordCount: words.length
        };
        
        // Remove if exists
        const filtered = recent.filter(d => d.hash !== currentDocHash);
        filtered.unshift(doc);
        
        // Keep only last 10
        const limited = filtered.slice(0, 10);
        localStorage.setItem('recentDocuments', JSON.stringify(limited));
        
        loadRecentDocuments();
      } catch (error) {
        console.error('Save recent document error:', error);
      }
    }

    function getRecentDocuments() {
      try {
        const recent = localStorage.getItem('recentDocuments');
        return recent ? JSON.parse(recent) : [];
      } catch (error) {
        console.error('Get recent documents error:', error);
        return [];
      }
    }

    function loadRecentDocuments() {
      try {
        const recent = getRecentDocuments();
        const recentDocs = document.getElementById('recentDocs');
        const recentList = document.getElementById('recentList');
        
        if (recent.length === 0) {
          recentDocs.classList.add('hidden');
          return;
        }
        
        recentDocs.classList.remove('hidden');
        recentList.innerHTML = '';
        
        recent.forEach(doc => {
          const div = document.createElement('div');
          div.className = 'recent-item';
          
          const timeAgo = getTimeAgo(doc.timestamp);
          const readingTime = Math.round(doc.wordCount / wpm);
          
          div.innerHTML = `
            <div class="recent-info">
              <div class="recent-name">${doc.name}</div>
              <div class="recent-meta">${doc.wordCount.toLocaleString()} words ‚Ä¢ ${readingTime} min at ${wpm} WPM ‚Ä¢ ${timeAgo}</div>
            </div>
          `;
          
          div.addEventListener('click', () => {
            const saved = getSavedPosition(doc.hash);
            if (saved) {
              alert('Document was saved. Please re-upload to continue.');
            }
          });
          
          recentList.appendChild(div);
        });
      } catch (error) {
        console.error('Load recent documents error:', error);
      }
    }

    function getTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'Just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    // Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
      if (readerScreen.classList.contains('active')) {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePlayPause();
          showButtons();
          if (isPlaying) {
            startFadeTimer();
          } else {
            clearFadeTimer();
          }
        } else if (e.code === 'Escape') {
          e.preventDefault();
          if (settingsPanel.classList.contains('active')) {
            settingsPanel.classList.remove('active');
          } else {
            exitBtn.click();
          }
        } else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          if (currentIndex > 0) {
            currentIndex--;
            updateDisplay();
          }
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          const chunkSize = readingMode === 'single' ? 1 : readingMode === 'chunk2' ? 2 : 3;
          if (currentIndex < words.length - chunkSize) {
            currentIndex += chunkSize;
            updateDisplay();
          }
        }
      }
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (words.length > 0) {
          updateDisplay();
        }
      }, 100);
    });

    window.addEventListener('resize', () => {
      if (words.length > 0) {
        const word = words[currentIndex];
        if (word) adjustFontSize(word);
      }
    });
  </script>
</body>
</html><label class="control-label">Preset Modes</label>
              <div class="preset-grid">
                <button class="preset-btn" data-mode="theta">
                  <div class="preset-name">üåô Theta (5 Hz)</div>
                  <div class="preset-desc">Deep relaxation & sleep reading</div>
                </button>
                <button class="preset-btn" data-mode="alpha">
                  <div class="preset-name">üßò Alpha (10 Hz)</div>
                  <div class="preset-desc">Calm learning & creativity</div>
                </button>
                <button class="preset-btn active" data-mode="beta">
                  <div class="preset-name">‚ö° Beta (15 Hz)</div>
                  <div class="preset-desc">Focus & active learning</div>
                </button>
                <button class="preset-btn" data-mode="gamma">
                  <div class="preset-name">üéØ Gamma (40 Hz)</div>
                  <div class="preset-desc">High alertness & peak performance</div>
                </button>
              </div>
            </div>
            
            <div class="control-group">
              <label class="control-label">Custom Frequency</label>
              <div class="control-item">
                <input type="number" class="custom-freq-input" id="customFreq" min="1" max="100" value="15" step="0.5">
                <span style="color: #999; font-size: 0.9rem;">Hz</span>
              </div>
            </div>
            
            <div class="control-group">
